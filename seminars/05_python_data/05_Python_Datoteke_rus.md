# Работа с файлами на

# языке программирования Python


## ТЕКСТОВЫЕ ФАЙЛЫ


# Текстовые файлы

● Текстовые файлы служат для постоянного
(постоянного) хранения данных в текстовом
формате на носителе массовой
памяти
● Текст в файле должен соответствовать какому-то
кодовому стандарту

- чаще всего ASCII или UTF-8


# Открытие файла

● Функция _open()_ возвращает файловый объект, который
представляет абстракцию Python над
файлом
● Обычно используется с двумя аргументами
_open(filename, mode)_

- f = open('workfile', 'w')


# Режимы открытия файла

● Параметр mode представляет режим, в котором файл
открывается

- 'r' - открывает файл в режиме для чтения
- 'w' - открывает файл в режиме для записи с тем
    что предыдущий содержимое файла (если оно было)
    уничтожается
- 'a' - открывает файл в режиме добавления в
    конец содержимого
- 'r+' режим позволяет и чтение, и запись
- параметр mode по умолчанию 'r'


# Чтение из файла

● Метод _read(size)_ объекта файла читает size
символов из файла и возвращает считанное значение
как строку
● Если size не указан, то _read()_ читает
весь содержимое файла
● Текстовый файл можно читать построчно с
помощью метода _readline()_ объекта файла


# Чтение из файла

● Через строки файла можно итерировать так

- for line in f:
    print(line, end='')
● Список всех строк можно получить с помощью list(f) или
f.readlines()
● Рекомендуется использовать **_with_** конструкцию
при работе с файлами
- with open('workfile') as f:
read_data = f.read()
● **_with_** гарантирует корректное закрытие файла даже
в случае возникновения исключения


# Запись в файл

● Метод _write(content)_ объекта файла записывает
переданный контент в файл, который был
открыт в режиме записи

- f.write('This is a test\n')
● _write()_ возвращает количество записанных символов
как возвращаемое значение
● Объекты, не являющиеся строкой, сначала
необходимо преобразовать в строку с помощью _str()_
и затем записать в текстовый файл


# Пример 1

● Создать текстовый файл и заполнить его 5
строками произвольного текста
● Прочитать созданный файл:

- символ за символом
- строка за строкой
- сразу
● Содержимое файла переписать в новый файл в
обратном порядке:
- строк
- символов


# Задача 1

- Загрузить произвольный текстовый файл и
    подсчитать:
       - символы
       - буквы
       - цифры
       - слова
       - предложения


# Задача 2

● З из входного файла загрузить данные об
автомобилях в массив
● Для введенного объема двигателя найти
самый новый автомобиль с объемом не более
заданного
● Пример файла:
AlfaRomeo 1200 2005
BMW 2200 2011
AUDI 1900 2010
Zastava 1600 1998
Ferrari 2500 2013


# Задача 3

● Для заданного символа c и натурального числа d
сформировать текстовый файл со знаком «квадрат» из
символов c, шириной и высотой 2d+1 символа
● Пример: c=#, d=
#
###
#####
#######
#####
###
#


## БИНАРНЫЕ ФАЙЛЫ


# Открытие, чтение и запись

● Бинарные файлы открываются так же, как
и текстовые, просто не

обходимо в _mode_
параметр добавить символ ‘b’

- f = open('workfile', 'rb+')
● Для чтения используется метод read(size), который
возвращает объект класса _bytes_
● Для записи используется метод write(content), где
content параметр имеет тип bytes
- f = open('workfile', 'rb+')


# Встроенный класс bytes

● Позволяет создавать объекты, содержащие
неизменяемый массив байтов

- x = b”some content”
● Поддерживает только ASCII значения как литералы, все
остальные символы задаются с использованием escape
последовательностей
● Для изменяемого массива байтов используется класс
_bytearray_
● Классы _bytes_ и _bytearray_ поддерживают большинство
стандартных методов строки:
- replace, removeprefix, join ...


# Навигация по бинарному файлу

● В отличие от текстовых файлов, которые чаще
всего читаются и записываются последовательно (от
начала до конца), при работе с бинарными
файлами часто необходимо перемещаться на
определенную позицию внутри файла
● Метод _tell()_ объекта файла возвращает текущую
позицию внутреннего индикатора внутри файла,
которая представляет собой количество байтов до
начала файла


# Навигация по бинарному файлу

● Метод _seek(offset, whence)_ позволяет
изменить позицию в файле

- _offset_ это количество байтов относительно
    опорной точки
- _whence_ опорная точка, и может быть:
    ● 0 - начало файла (значение по умолчанию)
    ● 1 - текущая позиция
    ● 2 - конец файла
● Примеры:
- _f.seek(5)_ # Перейти к 6-му байту в файле
- _f.seek(-3, 2)_ # Перейти к 3-му байту до конца


## Сериализация и десериализация объектов

## Python


● Модуль _pickle_ реализует бинарный протокол
для сериализации и десериализации объектов
Python
● _pickle_ поддерживает сериализацию и
десериализацию

- логических и числовых типов
- строк, кортежей
- списков, множеств, словарей, содержащих элементы, которые
    являются каким-то из перечисленных выше типов


## Сериализация и десериализация объектов

- Функция _pickle.dump(obj, file)_ позволяет
    сериализовать объект в бинарный файл
- Для обратной операции используется функция
    _pickle.load(file)_


# Пример 2

● Значение целочисленной переменной записать в
бинарный файл
● Прочитать созданный файл
● Удвоенное прочитанное значение записать в
новый файл


# Пример 3

● Значение строковой переменной записать в бинарный
файл
● Прочитать созданный файл
● К прочитанному значению добавить несколько не-
ASCII (UTF-8) символов и записать строку в новый
файл
● Прочитать UTF- 8 файл и прочитать только
последние 6 байт


# Пример 4

● Словарный объект сериализовать в файл
● Прочитать созданный файл
● Изменить десериализованный словарь
● Вывести измененный словарь в новый файл


# Задача 4

- Прочитайте CSV-файл как массив кортежей (tuple).
- Сериализуйте прочитанный массив в двоичный файл.
- Пример входного файла:
```
Grad, Uslovi, MinTemp, MaxTemp
Beograd, Oblačno, 6,12.5
Novi Sad, Oblačno, 5, 11
Subotica, Sunčano, 6, 12
Zrenjanin, Kišovito, 4, 11
Nevesinje, Sunčano, 6, 13
```

# Задача 5

- У вас есть двоичное изображение BMP.
- На втором байте находится размер файла (4 байта).
- На десятом байте находится размер заголовка файла (4 байта).
- Скопируйте байты из заголовка в новый файл.
- Загрузите остальные байты в переменную типа int (по одному).
- Выведите комплементарные значения (255 - x) в новый файл.
